{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pr\u00e9ambule Auteur Fourny Nathan : \u00c9tudiant | R\u00e9dacteur du rapport d'analyse Contexte Ce projet a \u00e9t\u00e9 r\u00e9alis\u00e9 dans le cadre du module \"Qualit\u00e9 Algorithmique | R5.04\" du BUT informatique 3e Ann\u00e9e. Objectif L'objectif de ce projet est d'analyser les performances des algorithmes de tri en Python. Pour cela, nous avons impl\u00e9ment\u00e9 les algorithmes de tri suivants : - Tri par s\u00e9lection - Tri par insertion - Tri rapide - Tri fusion Chaque tri ont \u00e9t\u00e9 test\u00e9 100 fois sur des liste de 500 \u00e9l\u00e9ments allant de -100 \u00e0 100. Analyse Ex\u00e9cution primaire Tri par s\u00e9lection On remarque ici que l'ex\u00e9cution du tri par s\u00e9lection est assez chaotique. On aper\u00e7oit de grande variation avec une m\u00e9diane d'ex\u00e9cution \u00e0 environ 0.0160s. Tri par insertion Le tri par insertion est plus stable que le tri par s\u00e9lection. Cependant on remarque que sa premi\u00e8re ex\u00e9cution est plus lente que les suivantes. En effet sa premi\u00e8re ex\u00e9cution dure environ 0.0125s alors qu'on peut situer sa m\u00e9diane \u00e0 environ 0.0110s. On remarque \u00e9galement que vers le dernier tier des it\u00e9rations, le temps d'execution devient de plus en plus court. Tri rapide D\u00e8s le premier coup d'oeil on remarque que le tri rapide semble beaucoup plus rapide, performant et stable que les deux pr\u00e9c\u00e9dents. Dans la quasi majorit\u00e9 des it\u00e9rations on voit que le temps d'ex\u00e9cution est stable vers 0.001s. Il est \u00e9galement tr\u00e8s int\u00e9r\u00e9ssant de noter que certaines it\u00e9rations sont tr\u00e8s rapides et estim\u00e9 \u00e0 0s d'ex\u00e9cution. soit instantan\u00e9. Tandis que d'autres sont nettement plus longues que les autres. Cela peut \u00eatre d\u00fb au changement de pivot que peut \u00eatre mal fait ce qui fait que l'algorithme passe d'une complexit\u00e9 O(n log n) \u00e0 O(n^2) dans le pire des cas. Tri fusion Le tri fusion est \u00e9galement tr\u00e8s diff\u00e9rents des autres. On remarque que le premiers tier d'ex\u00e9cution de l'algorithme est beaucoup plus lent et instable que les deux autres tiers. Cet algorithme n'est pas le plus rapide, il se place en seconde position derri\u00e8re le tri rapide avec une m\u00e9diane d'ex\u00e9cution \u00e0 environ 0.005s apr\u00e8s sa stabilisation. Comparaison des tris tri par s\u00e9lection vs tri par insertion En comparant les deux premiers tris les moins rapides (s\u00e9lection et insertion), on remarque bien que le tri \u00e0 insertion est \u00e0 tr\u00e8s grande majorit\u00e9 plus rapide que le tri par s\u00e9lection. Le tri par insertion semble ici plus stable que son concurrent m\u00eame si les deux algorithmes restent assez chaotiques par rapport aux autres. tri rapide vs tri fusion Dans ce comparatif entre les deux tris les plus rapide, on remarque bien que le tri rapide est beaucoup plus stable que son concurrent direct. Le tri fusion est beaucoup moins stable que le tri rapide avec de nombreuses variations de dur\u00e9e d'ex\u00e9cution entre chaque it\u00e9ration. On remarque une nouvelle fois que les deux algorithmes ont de grandes zones de stabilit\u00e9 lors de l'ex\u00e9cution. Comparaison globales L'\u00e9volution des tris avec des listes de plus en plus grandes Ici, on a compar\u00e9 chaque tris sur une liste d'\u00e9l\u00e9ments de plus en plus grandes (en partant de 100 \u00e9l\u00e9ments \u00e0 la base). On remarque bien la diff\u00e9rence de complexit\u00e9 entre les 4 algorithmes avec le tri par s\u00e9lection qui est quadratique, le tri par insertion qui est lin\u00e9aire et le tri fusion qui est logarithmique. On remarque que le tri rapide est quasi-constant ici, ce qui est tr\u00e8s int\u00e9r\u00e9ssant. Conclusion En conclusion, on peut dire que le tri rapide est le plus performant des 4 algorithmes test\u00e9s. Il est le plus rapide et le plus stable m\u00eame avec des listes de plus en plus grandes et il est le seul \u00e0 avoir une complexit\u00e9 quasi-constante. Le tri fusion est \u00e9galement un bon algorithme de tri, mais il est moins performant que le tri rapide. Sa complexit\u00e9 logarithmique lui permet de trier des listes de plus en plus grandes en un temps relativement court ce qui le rend plus performant que les deux premiers tris. Le tri par insertion est un algorithme de tri correct, mais il est moins performant que les deux pr\u00e9c\u00e9dents. Le tri par s\u00e9lection est le moins performant des 4 algorithmes test\u00e9s. Bien qu'il soit le tri utilis\u00e9 dans la grande majorit\u00e9 des cas par les humains, on se rend vite compte qu'il est tr\u00e8s peu performant. Pour les 4 algorithmes ce sont apr\u00e8s plusieurs it\u00e9rations et des listes de plus en plus grandes qu'on peut identifier une r\u00e9elle diff\u00e9rences d'optimisation et de performance entre chacun. De mani\u00e8re g\u00e9n\u00e9rale, il est int\u00e9r\u00e9ssant de noter que chaque tri s'effectue en un temps relativement court. Contrairement \u00e0 des tests r\u00e9alis\u00e9s sur des langages comme le C, les premi\u00e8res it\u00e9rations de chaque tris ne sont pas sp\u00e9cialement plus longues que les suivantes. Cela est probablement d\u00fb \u00e0 l'interpr\u00e9tation du code Python.","title":"Home"},{"location":"#preambule","text":"","title":"Pr\u00e9ambule"},{"location":"#auteur","text":"Fourny Nathan : \u00c9tudiant | R\u00e9dacteur du rapport d'analyse","title":"Auteur"},{"location":"#contexte","text":"Ce projet a \u00e9t\u00e9 r\u00e9alis\u00e9 dans le cadre du module \"Qualit\u00e9 Algorithmique | R5.04\" du BUT informatique 3e Ann\u00e9e.","title":"Contexte"},{"location":"#objectif","text":"L'objectif de ce projet est d'analyser les performances des algorithmes de tri en Python. Pour cela, nous avons impl\u00e9ment\u00e9 les algorithmes de tri suivants : - Tri par s\u00e9lection - Tri par insertion - Tri rapide - Tri fusion Chaque tri ont \u00e9t\u00e9 test\u00e9 100 fois sur des liste de 500 \u00e9l\u00e9ments allant de -100 \u00e0 100.","title":"Objectif"},{"location":"#analyse","text":"","title":"Analyse"},{"location":"#execution-primaire","text":"Tri par s\u00e9lection On remarque ici que l'ex\u00e9cution du tri par s\u00e9lection est assez chaotique. On aper\u00e7oit de grande variation avec une m\u00e9diane d'ex\u00e9cution \u00e0 environ 0.0160s. Tri par insertion Le tri par insertion est plus stable que le tri par s\u00e9lection. Cependant on remarque que sa premi\u00e8re ex\u00e9cution est plus lente que les suivantes. En effet sa premi\u00e8re ex\u00e9cution dure environ 0.0125s alors qu'on peut situer sa m\u00e9diane \u00e0 environ 0.0110s. On remarque \u00e9galement que vers le dernier tier des it\u00e9rations, le temps d'execution devient de plus en plus court. Tri rapide D\u00e8s le premier coup d'oeil on remarque que le tri rapide semble beaucoup plus rapide, performant et stable que les deux pr\u00e9c\u00e9dents. Dans la quasi majorit\u00e9 des it\u00e9rations on voit que le temps d'ex\u00e9cution est stable vers 0.001s. Il est \u00e9galement tr\u00e8s int\u00e9r\u00e9ssant de noter que certaines it\u00e9rations sont tr\u00e8s rapides et estim\u00e9 \u00e0 0s d'ex\u00e9cution. soit instantan\u00e9. Tandis que d'autres sont nettement plus longues que les autres. Cela peut \u00eatre d\u00fb au changement de pivot que peut \u00eatre mal fait ce qui fait que l'algorithme passe d'une complexit\u00e9 O(n log n) \u00e0 O(n^2) dans le pire des cas. Tri fusion Le tri fusion est \u00e9galement tr\u00e8s diff\u00e9rents des autres. On remarque que le premiers tier d'ex\u00e9cution de l'algorithme est beaucoup plus lent et instable que les deux autres tiers. Cet algorithme n'est pas le plus rapide, il se place en seconde position derri\u00e8re le tri rapide avec une m\u00e9diane d'ex\u00e9cution \u00e0 environ 0.005s apr\u00e8s sa stabilisation.","title":"Ex\u00e9cution primaire"},{"location":"#comparaison-des-tris","text":"tri par s\u00e9lection vs tri par insertion En comparant les deux premiers tris les moins rapides (s\u00e9lection et insertion), on remarque bien que le tri \u00e0 insertion est \u00e0 tr\u00e8s grande majorit\u00e9 plus rapide que le tri par s\u00e9lection. Le tri par insertion semble ici plus stable que son concurrent m\u00eame si les deux algorithmes restent assez chaotiques par rapport aux autres. tri rapide vs tri fusion Dans ce comparatif entre les deux tris les plus rapide, on remarque bien que le tri rapide est beaucoup plus stable que son concurrent direct. Le tri fusion est beaucoup moins stable que le tri rapide avec de nombreuses variations de dur\u00e9e d'ex\u00e9cution entre chaque it\u00e9ration. On remarque une nouvelle fois que les deux algorithmes ont de grandes zones de stabilit\u00e9 lors de l'ex\u00e9cution.","title":"Comparaison des tris"},{"location":"#comparaison-globales","text":"L'\u00e9volution des tris avec des listes de plus en plus grandes Ici, on a compar\u00e9 chaque tris sur une liste d'\u00e9l\u00e9ments de plus en plus grandes (en partant de 100 \u00e9l\u00e9ments \u00e0 la base). On remarque bien la diff\u00e9rence de complexit\u00e9 entre les 4 algorithmes avec le tri par s\u00e9lection qui est quadratique, le tri par insertion qui est lin\u00e9aire et le tri fusion qui est logarithmique. On remarque que le tri rapide est quasi-constant ici, ce qui est tr\u00e8s int\u00e9r\u00e9ssant.","title":"Comparaison globales"},{"location":"#conclusion","text":"En conclusion, on peut dire que le tri rapide est le plus performant des 4 algorithmes test\u00e9s. Il est le plus rapide et le plus stable m\u00eame avec des listes de plus en plus grandes et il est le seul \u00e0 avoir une complexit\u00e9 quasi-constante. Le tri fusion est \u00e9galement un bon algorithme de tri, mais il est moins performant que le tri rapide. Sa complexit\u00e9 logarithmique lui permet de trier des listes de plus en plus grandes en un temps relativement court ce qui le rend plus performant que les deux premiers tris. Le tri par insertion est un algorithme de tri correct, mais il est moins performant que les deux pr\u00e9c\u00e9dents. Le tri par s\u00e9lection est le moins performant des 4 algorithmes test\u00e9s. Bien qu'il soit le tri utilis\u00e9 dans la grande majorit\u00e9 des cas par les humains, on se rend vite compte qu'il est tr\u00e8s peu performant. Pour les 4 algorithmes ce sont apr\u00e8s plusieurs it\u00e9rations et des listes de plus en plus grandes qu'on peut identifier une r\u00e9elle diff\u00e9rences d'optimisation et de performance entre chacun. De mani\u00e8re g\u00e9n\u00e9rale, il est int\u00e9r\u00e9ssant de noter que chaque tri s'effectue en un temps relativement court. Contrairement \u00e0 des tests r\u00e9alis\u00e9s sur des langages comme le C, les premi\u00e8res it\u00e9rations de chaque tris ne sont pas sp\u00e9cialement plus longues que les suivantes. Cela est probablement d\u00fb \u00e0 l'interpr\u00e9tation du code Python.","title":"Conclusion"}]}