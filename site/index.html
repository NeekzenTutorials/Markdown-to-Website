<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="None" />
      <link rel="shortcut icon" href="img/favicon.ico" />
    <title>Cpost Wiki</title>
    <link rel="stylesheet" href="css/theme.css" />
    <link rel="stylesheet" href="css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Home";
        var mkdocs_page_input_path = "index.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="." class="icon icon-home"> Cpost Wiki
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Home</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#auteur">Auteur</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#contexte">Contexte</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#objectif">Objectif</a>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href=".">Cpost Wiki</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Home</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="preambule">Préambule</h2>
<h3 id="auteur">Auteur</h3>
<ul>
<li>Fourny Nathan : Étudiant | Rédacteur du rapport d'analyse</li>
</ul>
<h3 id="contexte">Contexte</h3>
<p>Ce projet a été réalisé dans le cadre du module "Qualité Algorithmique | R5.04" du BUT informatique 3e Année.</p>
<h3 id="objectif">Objectif</h3>
<p>L'objectif de ce projet est d'analyser les performances des algorithmes de tri en Python. Pour cela, nous avons implémenté les algorithmes de tri suivants :
- Tri par sélection
- Tri par insertion
- Tri rapide
- Tri fusion</p>
<p>Chaque tri ont été testé 100 fois sur des liste de 500 éléments allant de -100 à 100.</p>
<h2 id="analyse">Analyse</h2>
<h3 id="execution-primaire">Exécution primaire</h3>
<ul>
<li>Tri par sélection</li>
</ul>
<p>On remarque ici que l'exécution du tri par sélection est assez chaotique. On aperçoit de grande variation avec une médiane d'exécution à environ 0.0160s. </p>
<p><img alt="tri_selection_1.png" src="img/tri_selection_1.png" /></p>
<ul>
<li>Tri par insertion</li>
</ul>
<p>Le tri par insertion est plus stable que le tri par sélection. Cependant on remarque que sa première exécution est plus lente que les suivantes. En effet sa première exécution dure environ 0.0125s alors qu'on peut situer sa médiane à environ 0.0110s.<br />
On remarque également que vers le dernier tier des itérations, le temps d'execution devient de plus en plus court.</p>
<p><img alt="tri_insertion_1.png" src="img/tri_insertion_1.png" /></p>
<ul>
<li>Tri rapide</li>
</ul>
<p>Dès le premier coup d'oeil on remarque que le tri rapide semble beaucoup plus rapide, performant et stable que les deux précédents.<br />
Dans la quasi majorité des itérations on voit que le temps d'exécution est stable vers 0.001s.<br />
Il est également très intéréssant de noter que certaines itérations sont très rapides et estimé à 0s d'exécution. soit instantané. Tandis que d'autres sont nettement plus longues que les autres. Cela peut être dû au changement de pivot que peut être mal fait ce qui fait que l'algorithme passe d'une complexité O(n log n) à O(n^2) dans le pire des cas.</p>
<p><img alt="tri_rapide_1.png" src="img/tri_rapide_1.png" /></p>
<ul>
<li>Tri fusion</li>
</ul>
<p>Le tri fusion est également très différents des autres. On remarque que le premiers tier d'exécution de l'algorithme est beaucoup plus lent et instable que les deux autres tiers.<br />
Cet algorithme n'est pas le plus rapide, il se place en seconde position derrière le tri rapide avec une médiane d'exécution à environ 0.005s après sa stabilisation.</p>
<p><img alt="tri_fusion_1.png" src="img/tri_fusion_1.png" /></p>
<h3 id="comparaison-des-tris">Comparaison des tris</h3>
<ul>
<li>tri par sélection vs tri par insertion</li>
</ul>
<p>En comparant les deux premiers tris les moins rapides (sélection et insertion), on remarque bien que le tri à insertion est à très grande majorité plus rapide que le tri par sélection.<br />
Le tri par insertion semble ici plus stable que son concurrent même si les deux algorithmes restent assez chaotiques par rapport aux autres.</p>
<p><img alt="tri_selection_insertion.png" src="img/tri_selection_insertion.png" /></p>
<ul>
<li>tri rapide vs tri fusion</li>
</ul>
<p>Dans ce comparatif entre les deux tris les plus rapide, on remarque bien que le tri rapide est beaucoup plus stable que son concurrent direct. Le tri fusion est beaucoup moins stable que le tri rapide avec de nombreuses variations de durée d'exécution entre chaque itération.<br />
On remarque une nouvelle fois que les deux algorithmes ont de grandes zones de stabilité lors de l'exécution.</p>
<p><img alt="tri_rapide_fusion.png" src="img/tri_rapide_fusion.png" /></p>
<h3 id="comparaison-globales">Comparaison globales</h3>
<ul>
<li>L'évolution des tris avec des listes de plus en plus grandes</li>
</ul>
<p>Ici, on a comparé chaque tris sur une liste d'éléments de plus en plus grandes (en partant de 100 éléments à la base).<br />
On remarque bien la différence de complexité entre les 4 algorithmes avec le tri par sélection qui est quadratique, le tri par insertion qui est linéaire et le tri fusion qui est logarithmique.<br />
On remarque que le tri rapide est quasi-constant ici, ce qui est très intéréssant.</p>
<p><img alt="tri_comparaison_supp.png" src="img/tris_comparaison_supp.png" /></p>
<h2 id="conclusion">Conclusion</h2>
<p>En conclusion, on peut dire que le tri rapide est le plus performant des 4 algorithmes testés. Il est le plus rapide et le plus stable même avec des listes de plus en plus grandes et il est le seul à avoir une complexité quasi-constante.</p>
<p>Le tri fusion est également un bon algorithme de tri, mais il est moins performant que le tri rapide. Sa complexité logarithmique lui permet de trier des listes de plus en plus grandes en un temps relativement court ce qui le rend plus performant que les deux premiers tris.</p>
<p>Le tri par insertion est un algorithme de tri correct, mais il est moins performant que les deux précédents.</p>
<p>Le tri par sélection est le moins performant des 4 algorithmes testés. Bien qu'il soit le tri utilisé dans la grande majorité des cas par les humains, on se rend vite compte qu'il est très peu performant.</p>
<p>Pour les 4 algorithmes ce sont après plusieurs itérations et des listes de plus en plus grandes qu'on peut identifier une réelle différences d'optimisation et de performance entre chacun.</p>
<p>De manière générale, il est intéréssant de noter que chaque tri s'effectue en un temps relativement court. Contrairement à des tests réalisés sur des langages comme le C, les premières itérations de chaque tris ne sont pas spécialement plus longues que les suivantes. Cela est probablement dû à l'interprétation du code Python.</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="js/jquery-3.6.0.min.js"></script>
    <script>var base_url = ".";</script>
    <script src="js/theme_extra.js"></script>
    <script src="js/theme.js"></script>
      <script src="search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>

<!--
MkDocs version : 1.6.1
Build Date UTC : 2024-09-20 12:45:47.433318+00:00
-->
